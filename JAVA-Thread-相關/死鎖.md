---
aliases:
  - DeadLock
  - deadlock
---
# 定義:
不同的 [[Thread]] 同時占用者對方所需要的[[synchronized|同步]]資源，都在等待對方放棄自己所需要的[[synchronized|同步]]資源。![[Pasted image 20240429135410.png]]
# 範例:
>[!NOTE] 死鎖範例
>可以看到 [[Thread]] main 調用了 a.foo(b)，而此時 [[Thread]] main 就握住了 object a 這個鎖，而 [[Thread]] dl 則調用了 b.bar(a)，此時 [[Thread]] dl 則握住了 object b 這個鎖，而當 a.foo(b) 執行到 b.last() 時，卻因為 [[Thread]] dl 此時還握者 object b 這把鎖，因此 [[Thread]] main 需要等待 [[Thread]] dl 釋放 object b，而 b.bar(a) 執行到 a.last() 時，也正在等待 [[Thread]] main 釋放 object a 這把鎖，此時就造成了兩個[[Thread|線程]]都在等待對方釋放自己要的資源的局面，從而造成了死鎖的場景。
>補充:也可能是副[[Thread|線程]]先調用 b.bar(a) 後主[[Thread|線程]]才調用 a.foo(b)。
>```java
>public class DeadLock implements Runnable {  
A a = new A();  
B b = new B();  
public void init() {  
Thread.currentThread().setName("主线程");  
// 调用a对象的foo方法  
a.foo(b);  
System.out.println("进入了主线程之后");  
}  
public void run() {  
Thread.currentThread().setName("副线程");  
// 调用b对象的bar方法  
b.bar(a);  
System.out.println("进入了副线程之后");  
}  
public static void main(String[] args) {  
DeadLock dl = new DeadLock();  
//開啟並執行副線程
new Thread(dl).start();  
//主線程
dl.init();  
}  
}  
class A {  
public synchronized void foo(B b) {  
System.out.println("当前线程名: " + Thread.currentThread().getName()   + " 进入了A实例的foo方法"); // ①  
try {  
Thread.sleep(200);  
} catch (InterruptedException ex) {  
ex.printStackTrace();  
}  
System.out.println("当前线程名: " + Thread.currentThread().getName()  + " 企图调用B实例的last方法"); // ③  
b.last();  
}  
public synchronized void last() {  
System.out.println("进入了A类的last方法内部");  
}  
}  
class B {  
public synchronized void bar(A a) {  
System.out.println("当前线程名: " + Thread.currentThread().getName()  + " 进入了B实例的bar方法"); // ②  
try {  
Thread.sleep(200);  
} catch (InterruptedException ex) {  
ex.printStackTrace();  
}  
System.out.println("当前线程名: " + Thread.currentThread().getName()  + " 企图调用A实例的last方法"); // ④  
a.last();  
}  
public synchronized void last() {  
System.out.println("进入了B类的last方法内部");  
}  
}
>
>```
# 死鎖產生的原因及解決
只要以下 4 點有其中一點被解決，死鎖就不存在。
## 1.互斥使用(mutual exclusion)
### 定義:
指的是當鎖被某個線程占用時，其他線程就得等。
### 解決:
無法解決，因為這是由 JAVA 語法 synchronized 所規範的，synchronized 就是透過互斥來解決線程安全問題。
## 2.持有和等待(hold and wait)
### 定義:
Thread 可以在請求其他鎖的同時，握住目前的鎖。
### 解決:
可以讓 Thread 同時請求所有的鎖，而不再是順序的獲得鎖。
## 3.禁止搶占(no preemption)
### 定義:
當資源已經被某個 Thread 佔領時，新的資源請求者(指其他 Thread )不可強制讓目前的資源佔有者強制退出，資源只能由目前的資源佔有者主動釋放。
### 解決:
占用資源的線程在申請其他資源時，若等待了一段時間還申請不到其他資源，則可以主動釋放目前的資源。
## 4.循環等待(circular waiting)
### 定義:
就是之前的範例。
### 解決:
可以把資源排序，每個線程在獲取資源時，都按照此順序在獲得，這樣就不會出現不同線程手握對方需要的資源在互相等待。