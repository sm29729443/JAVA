---
aliases:
---

# 什麼情況下[[Thread|線程]]會需要通訊
當希望透過多個[[Thread|線程]]協調合作，來完成一件任務時，就需要讓[[Thread|線程]]之間彼此通訊協調，使[[Thread|線程]]間按照我們設計的順序執行，來完成任務，而[[Thread|線程]]的通訊機制就是等待與喚醒機制，也就是透過 wait()、notify() 兩個 method 來進行[[Thread|線程]]間的通訊。
# 範例
>[!NOTE] 題目:兩個線程交叉打印 0-100
>```java
>/*  
題目:兩個線程交叉打印 0-100*/  
public class CommunicationTest {  
public static void main(String[] args) {  
PrintNumber printNumber = new PrintNumber();  
Thread t1 = new Thread(printNumber);  
Thread t2 = new Thread(printNumber);  
t1.setName("線程 1");  
t2.setName("線程 2");  
t1.start();  
t2.start();  
}  
}  
class PrintNumber implements Runnable {  
private static int number = 0;  
@Override  
public void run() {  
while (true) {  
synchronized (this) {  
// 當 Thread 執行此 method 時，會去喚醒被 wait() 的 Thread 中優先級最高的 Thread// 如果優先級相同則隨機喚醒一個，而此範例因為只有兩個 Thread，  
// 因此當 線程2 執行到此方法時，喚醒的一定是 線程1  
// 被喚醒的 Thread 會從當初被 wait() 的地方開始執行  
notify();  
if (number < 100) {  
try {  
Thread.sleep(100);  
} catch (InterruptedException e) {  
throw new RuntimeException(e);  
}  
number++;  
System.out.println(Thread.currentThread().getName() + ", number:" + number);  
try {  
// Thread 一旦執行此 method 則會進入等待狀態，並且 Thread 會釋放  
// 對 monitor 的調用  
wait();  
} catch (InterruptedException e) {  
throw new RuntimeException(e);  
}  
} else {  
break;  
}  
}  
}  
}  
}
# 注意點
1. [[Thread|線程]]的通訊會涉及到 3 個 method:
	wait(): 此 method 會讓 [[Thread]] 進入等待狀態。
	notify(): 此 method 會喚醒處於等待狀態中優先級最高的 [[Thread]]，若優先級相同，則隨機喚醒一個，而被喚醒的 [[Thread]]，會從被 wait() 的地方開始執行。
	notifyAll():喚醒所有處於等待狀態的 [[Thread]]。
2. 以上 3 個 method 只能在 [[synchronized]] 裡使用。
3. 此 3 個 method 的調用者必須是[[synchronized|同步]]監視器(monitor)。

# 範例:生產者與消費者
這邊先跳過，之後再回來補影片。